using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace JMGBE.Core
{
	public class MMU
	{
		private byte[] bootrom = new byte[256]
		{
			0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
			0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
			0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
			0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
			0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
			0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
			0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
			0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
			0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
			0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
			0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
			0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
			0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
			0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
			0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
			0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
		};
		
		private byte[] cartridge_data = new byte[32768];

		private byte[] memory = new byte[65536];

		//FF00 (JOYP)
		public byte JOYP
		{
			get { return memory[0xFF00]; }
			set { memory[0xFF00] = value; }
		}
		//FF40 (LCDC)
		public byte LCDC
		{
			get { return memory[0xFF40]; }
			set { memory[0xFF40] = value; }
		}
		//FF41 (STAT)
		public byte STAT
		{
			get { return memory[0xFF41]; }
			set { memory[0xFF41] = value; }
		}
		//FF42 (SCY)
		public byte SCY
		{ 
			get { return memory[0xFF42]; } 
			set { memory[0xFF42] = value; }
		}
		//FF43 (SCX)
		public byte SCX
		{ 
			get { return memory[0xFF43]; } 
			set { memory[0xFF43] = value; }
		}
		//FF44 (LY)
		public byte LY
		{
			get { return memory[0xFF44]; }
			set { memory[0xFF44] = value; }
		}
		//FF45 (LYC)
		public byte LYC
		{
			get { return memory[0xFF45]; }
			set { memory[0xFF45] = value; }
		}
		//FF46 (DMA)
		public byte DMA
		{
			get { return memory[0xFF46]; }
			set { memory[0xFF46] = value; }
		}
		//FF47 (BGP)
		public byte BGP
		{
			get { return memory[0xFF47]; }
			set { memory[0xFF47] = value; }
		}
		//FF48 (OBP0)
		public byte OBP0
		{
			get { return memory[0xFF48]; }
			set { memory[0xFF48] = value; }
		}
		//FF49 (OBP1)
		public byte OBP1
		{
			get { return memory[0xFF49]; }
			set { memory[0xFF49] = value; }
		}
		//FF4A (WY)
		public byte WY
		{
			get { return memory[0xFF4A]; }
			set { memory[0xFF4A] = value; }
		}
		//FF4B (WX)
		public byte WX
		{
			get { return memory[0xFF4B]; }
			set { memory[0xFF4B] = value; }
		}
		//FF50 (DBGROM)
		public byte DBGROM
		{
			get { return memory[0xFF50]; }
			set { memory[0xFF50] = value; }
		}
		//FFFF (IE)
		public byte IE
		{
			get { return memory[0xFFFF]; }
			set { memory[0xFFFF] = value; }
		}

		//Basic Read/Write functions.
		public byte ReadByte(int addr) 
		{
			System.Diagnostics.Debug.Assert(addr >= 0 && addr <= 0xFFFF);
			if (addr >= 0 && addr <= 0xFF)
				return DBGROM == 0 ? bootrom[addr] : cartridge_data[addr];
			return memory[addr];
		}
		public void WriteByte(int addr, byte value)
		{
			//The section [0x0000 - 0x7FFF] is ROM.
			System.Diagnostics.Debug.Assert(addr >= 0x8000 && addr <= 0xFFFF);
			//The section [0xFEA0 - 0xFEFF] is not usable.
			System.Diagnostics.Debug.Assert(!(addr >= 0xFEA0 && addr <= 0xFEFF));
			memory[addr] = value;
			if (addr >= 0xC000 && addr <= 0xDDFF)
				memory[addr + 0x2000] = value;
			else if (addr >= 0xE000 && addr <= 0xFDFF)
				memory[addr - 0x2000] = value;
		}
		//Complex Read/Write functions.
		public sbyte ReadSByte(int addr)
		{
			return (sbyte)ReadByte(addr);
		}
		public void LoadRom(string filename)
		{
			File.ReadAllBytes(filename).CopyTo(memory, 0);
			File.ReadAllBytes(filename).CopyTo(cartridge_data, 0);
		}
	}
}